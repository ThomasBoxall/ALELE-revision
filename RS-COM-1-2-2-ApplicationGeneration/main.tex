\documentclass[a4paper,11pt, twocolumn]{article}
\usepackage[margin=0.8in]{geometry}
\usepackage{xcolor}
\usepackage{graphicx} %package to manage images
\graphicspath{ {./images/} }
\usepackage{tabularx}
\usepackage{float}

\title{1-2-2 Applications Generation}
\author{Revision sheet}
\date{}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{} % clear all header fields
\renewcommand{\headrulewidth}{0pt} % no line in header area
\fancyfoot{} % clear all footer fields
\renewcommand{\footrulewidth}{0.4pt}
\fancyfoot[C]{\thepage} % page number in centre of the page
\fancyfoot[R]{\footnotesize Thomas Boxall \\ } % right hand footer has author name on top line and images reference on bottom line
\fancyfoot[L]{\footnotesize 1-2-2 Applications Generation \\ Revision sheet} % left hand footer has title of document on top line and 'Revision Sheet' on bottom line


\begin{document}

\maketitle
\thispagestyle{fancy}

% CONTENTS OF THE REVISION SHEET HERE
\section{The Nature of Applications}
There are to broad categories of software - systems software and applications software. 
\subsection{Systems Software}
This is the software needed to run the computer's hardware and application programs. This includes the operating system, utility programs, libraries and translators.
\subsubsection{Operating System}
This is a set of programs that lies between applications software and the hardware of the computer. It has a number of different functions including: resource management and providing a user interface.
\subsubsection{Utility Programs}
This is a category of systems software which is designed to optimise the performance of the computer of perform tasks such as managing and compressing/decompressing data and files and providing firewall. There are a number of different types
\begin{itemize}
    \item Disk defragmentation;
    \item Automatic backup;
    \item Automatic updating;
    \item Virus checker;
    \item Compression software.
\end{itemize}
\subsection{Applications Software}
This can be categorised into two categories.
\subsubsection{General-Purpose software}
This is software which can be used for a variety of tasks. Examples include: word-processors, spreadsheet or graphics packages. 
\subsubsection{Special-Purpose Software}
This performs a single specific task or set of tasks. Examples include: restaurant reservation managers, web browsers and media players. There are two different types of special-purpose software: \textit{off the shelf} and \textit{bespoke}. Each have their own pros and cons.
\begin{table}[H]
    \centering
    \begin{tabularx}{0.45\textwidth}{X|X}
        \textbf{Off The Shelf} & \textbf{Bespoke}\\
        \hline
        Less expensive as cost is shared between multiple license holders & Expensive and requires experts to design solution\\
        \hline
        May contain some unwanted features and some less-essential features & Features are customised to the client, more features added as they are needed\\
        \hline
        Ready to deploy immediately & Can take a long time to develop\\
        \hline
        Well documented, tested and error free & May contain errors which don't get shown immediately
    \end{tabularx}
    \caption{Comparison of Off The Shelf and Bespoke software}
\end{table}

\section{Sources of Software}
There are two main sources of software, open source and closed source.
\subsection{Open Source}
Open source software is governed by the \textit{Open Source Initiative} that says: there is no charge for the software, anyone can use it; open source software must be distributed with the source code so anyone can use it; developers can sell the software that they have created; any new iterations or branches from the original open source project must also be open. Usually there is community based tech support available, with minimal support made available from the original developer.
\subsection{Closed Source}
Closed sourced (proprietary) software is usually sold, with a license required to use it. There will be restrictions on how the software is used; for example, a single license may only allow one concurrent user or may permit up to 25 users on one site. The company or person who wrote the software will hold the copyright. Users will not have access to the source code and will not be allowed to modify the package. There is also usually tech support available from the developer/company.

\section{Programming Language Translation}
Humans write code in whatever language fits the project they are writing. This high level language needs to be converted into a low level language which can be run by whatever device it is intended to be run on. This low level language which machines can run is called machine code and is written in pure binary (but is often displayed in hex). There are three different translators which can be used: Compilers, Interpreters and Assemblers.
\subsection{Assembler}
Assemblers translate assembly code to machine code. Assembly language is also a low level language which makes use of mnemonics for each command. The assembler assembles the entire program at once, this means once assembled, the program can be run again and again.
\subsection{Interpreters}
Interpreters translate and run source code into machine code line by line, this means they are very good for pinpointing errors as they will be shown as soon as they are encountered. It does not create an executable file at the end of translation so every time the program is run, it will have to be interpreted which makes it slow at runtime. There is quite a significant disadvantage to compilers - each statement has to be translated into machine code every time it is encountered. 
\subsubsection{Bytecode}
This is an intermediary stage between an interpreted language and machine code. In some cases, \textit{Java}, the whole program is compiled into Bytecode first then run within a virtual machine (\textit{Java Virtual Machine - JVM}). Within the virtual machine, the bytecode is interpreted. Using bytecode allows for greater platform compatibility as the virtual machine is the thing interfacing with the operating system, not the individual applications.
\subsection{Compilation}
Compilers translate the whole program 'at once' into machine code. A compiler may scan through the source code multiple times before producing object code (machine code which is missing bits that Linkers fill in). Compiling may take some time, but once complete, it produces an executable file which can be run without the need to compile again. Errors are listed in the error report which is produced once the full program has been compiled. These errors can only be fixed by changing the original source code and compiling the program again.
\subsection{Comparison}
Compilers have many advantages over interpreters: the object code can be saved to disk and run whenever the program is needed, without having to be recompiled every time; the object code is faster than interpreted code; the object code produced by a compiler can be distributed or executed without having to have a compiler present; the object code is more secure (a lot of effort would be required to reverse engineer it). Interpreters also have advantages over compilers: platform independence; quicker runtime loading as there is no lengthy compilation required every time it is run.

\section{Stages of Compilation}
There are three stages of compilation.
\subsection{Lexical Analysis}
\begin{enumerate}
    \item Extra spaces are removed
    \item All comments are removed
    \item Simple error checking
    \begin{itemize}
        \item illegal identifiers would be flagged as an error
        \item assignments of illegal values to data types would be flagged as an error
    \end{itemize}
    \item All elements are identified then tokenised
    \item The variable names / identifiers are put in the symbol table.
\end{enumerate}
Tokens are a string of binary digits of a fixed length. The symbol table lists each identified token and what type of symbol it is.
\subsection{Syntax Analysis}
\begin{enumerate}
    \item Accepts the output from lexical Analysis
    \item Statements and arithmetic expressions/tokens are checked against the rules of the language (defined in Backus-Naur Form), for example are all the brackets matched and used correctly.
    \item Produce a list of errors which are outputted at the end of compilation. If there are no errors, the code is passed to code generation as an \textit{abstract syntax tree} with any additional details added (eg. data types, scopes, addresses).
\end{enumerate}
\subsubsection{Semantic Analysis}
Syntax analysis also includes semantic analysis. This is where the compiler identifies if \textit{identifiers are used appropriately throughout the whole program}. For example: variable not declared multiple times; variable assigned before referenced; assignment compatible with declared type; operations on variables compatible with type.
\subsection{Code Generation}
This is the last phase of compilation. It produces machine code/executable/intermediate code which is equivalent to the source program. During this phase, variables and constants are given addresses and relative addresses are calculated. The code can also be optimised here.
\subsubsection{Optimisation}
This makes the code as efficient as possible. It increases processing speed, generally by reducing the number of instruction; programmers can choose this however, either increasing speed or reducing size. It can include: loop optimisation; making calculations more efficient and changing relative addresses to absolute in memory. 

\section{Linkers, Loaders and Libraries}
Linking and loading are often done together by the same software but are considered separate processes. 
\subsection{Linkers}
Linkers (or Link Editors) are computer programs that take one or more object files generated by a computer and compiles them into a single executable file, library file or another object file.\\
\textbf{Dynamic Linkers:} The part of an operating system that loads and links the shared libraries (DLLs) for an executable file.
\subsubsection{Difference between static and dynamic linking}
In static linking, the linker copies all of the library routines used in the program into the executable image. This requires more disk space and memory than dynamic linking but is both faster and more portable; it also doesn't require the presence of the library on the system where it is run. Dynamic linking places the name of the shareable library in the executable image, actual linking with the library routine doesn't occur until the image is run, when both the executable and library are placed in memory; an advantage is that multiple programs can share a single copy of the library. 
\subsection{Loaders}
The loader is the part of the operating system that is responsible for loading programs and libraries into memory, only when dynamic linking is used. It reads the contents of the executable file containing the program instructions and carries out the tasks required for prepare the executable for running. Once loading is complete, the operating system starts the program by passing control to the loaded program code. 

\end{document}